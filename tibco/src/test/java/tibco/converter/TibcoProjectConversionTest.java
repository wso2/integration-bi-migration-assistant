/*
 *  Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com).
 *
 *  WSO2 LLC. licenses this file to you under the Apache License,
 *  Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package tibco.converter;

import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;
import tibco.TibcoToBalConverter;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.stream.Stream;

public class TibcoProjectConversionTest {

    @Test(groups = {"tibco", "converter"}, dataProvider = "projectTestCaseProvider")
    public void testProjectConversion(Path tibcoProject, Path expectedBallerinaProject) throws IOException {
        // Create a temporary directory for the output
        Path tempDir = Files.createTempDirectory("tibco-conversion-test");
        // Create a ProjectConversionContext with verbose logger for test
        TibcoToBalConverter.ProjectConversionContext cx = new TibcoToBalConverter.ProjectConversionContext(
                true, false, new ArrayList<>(), TibcoConverter.createVerboseLogger("test"));
        try {
            if ("true".equalsIgnoreCase(System.getenv("BLESS"))) {
                TibcoConverter.migrateTibcoProject(cx, tibcoProject.toString(), expectedBallerinaProject.toString(),
                        false);
            }
            // Run the conversion
            TibcoConverter.migrateTibcoProject(cx, tibcoProject.toString(), tempDir.toString(), false);

            // Compare the directories
            compareDirectories(tempDir, expectedBallerinaProject);
        } finally {
            // Clean up temporary directory
            deleteDirectory(tempDir);
        }
    }

    private void compareDirectories(Path actual, Path expected) throws IOException {
        // First check if both directories exist
        Assert.assertTrue(Files.isDirectory(actual), "Actual path is not a directory: " + actual);
        Assert.assertTrue(Files.isDirectory(expected), "Expected path is not a directory: " + expected);

        // Compare directory contents
        try (Stream<Path> expectedFiles = Files.walk(expected);
             Stream<Path> actualFiles = Files.walk(actual)) {

            // Get relative paths for comparison, filtering only .bal files
            var expectedPaths = expectedFiles
                    .filter(Files::isRegularFile)
                    .filter(path -> path.toString().endsWith(".bal"))
                    .map(expected::relativize)
                    .toList();

            var actualPaths = actualFiles
                    .filter(Files::isRegularFile)
                    .filter(path -> path.toString().endsWith(".bal"))
                    .map(actual::relativize)
                    .toList();

            // Check if all expected .bal files exist
            for (Path relativePath : expectedPaths) {
                if (relativePath.endsWith("types.bal")) {
                    // Skip types.bal as it is generated and may differ
                    continue;
                }
                Assert.assertTrue(actualPaths.contains(relativePath),
                        "Missing .bal file in actual directory: " + relativePath);

                // Compare file contents
                Path expectedFile = expected.resolve(relativePath);
                Path actualFile = actual.resolve(relativePath);
                compareFiles(actualFile, expectedFile);
            }

            // Check for extra .bal files
            for (Path relativePath : actualPaths) {
                if (relativePath.endsWith("types.bal")) {
                    // Skip types.bal as it is generated and may differ
                    continue;
                }
                Assert.assertTrue(expectedPaths.contains(relativePath),
                        "Extra .bal file in actual directory: " + relativePath);
            }
        }
    }

    private void compareFiles(Path actual, Path expected) throws IOException {
        if (actual.toString().contains("types") || actual.toString().contains(".html")) {
            // These are generated by XSD core and change from run to run
            return;
        }
        String actualContent = Files.readString(actual);
        String expectedContent = Files.readString(expected);
        Assert.assertEquals(actualContent, expectedContent,
                "File contents do not match for: " + actual.getFileName());
    }

    private void deleteDirectory(Path directory) throws IOException {
        if (Files.exists(directory)) {
            Files.walk(directory)
                    .sorted((a, b) -> -a.compareTo(b)) // Reverse order to delete files before directories
                    .forEach(path -> {
                        try {
                            Files.delete(path);
                        } catch (IOException e) {
                            throw new RuntimeException("Failed to delete: " + path, e);
                        }
                    });
        }
    }

    @DataProvider
    public Object[][] projectTestCaseProvider() throws IOException {
        Path projectTestCaseDir = Path.of("src", "test", "resources", "tibco.projects");
        Path expectedConvertedResultsDir = Path.of("src", "test", "resources", "tibco.projects.converted");

        // Get only the immediate directories (non-recursive)
        return Files.list(projectTestCaseDir)
                .filter(Files::isDirectory)
                .map(dir -> new Object[]{
                        dir,
                        expectedConvertedResultsDir.resolve(dir.getFileName())
                })
                .toArray(Object[][]::new);
    }
}
